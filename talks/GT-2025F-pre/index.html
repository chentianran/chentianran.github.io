---
layout: mtalk
title: GT 2025 pre-talk
---
<section class="titlepage">
    <div class="titlebox">
        <h2 class="title">
            Mixed volume, mixed cells, and stable intersections
        </h2>
    </div>
    <br/>
    <p>Tianran Chen</p>
    <p class="smaller">
        Department of Mathematics<br>
        Auburn University at Montgomery
    </p>
    <br/>
    <br/>
    <p class="smaller">
        September 8, 2025<br/>
        Georgia Institute of Technology
        <br/>
        Atlanta, GA
    </p>
</section>
<section>
    <h3>Mixed volume</h3>
    <div class="definition">
        Given convex polytopes (bodies) $P_1,\ldots,P_n$,
        their <strong class="highlight">mixed volume</strong>
        ($\operatorname{MV}(P_1,\ldots,P_n)$) is the coefficient of
        the monomial $\lambda_1 \cdots \lambda_n$
        in the homogeneous polynomial
        \[
            \operatorname{vol}(\lambda_1 P_1 + \cdots + \lambda_n P_n)
        \]
    </div>
    <div class="theorem fragment">
        Mixed volume equals to the sum of the volumes of
        the mixed cells in a <em class="highlight">mixed subdivision</em>.
    </div>
    <div class="theorem fragment">
        (Bernshtein-Kushnirenko-Khovanskii)
        Given a system of Laurent polynomials
        $f_1,\dots,f_n$ in $(x_1,\dots,x_n)$
        with <span class="emph">generic</span> coefficients,
        the number of isolated common roots in
        $(\mathbb{C}^*)^n$ is bounded by
        \[ \text{MV}(\text{Newt}(f_1),\dots,\text{Newt}(f_n)) \]
    </div>
</section>
<section data-auto-animate>
    <h3>Minkowski sum</h3>
    <p>
        \[
            \text{Minkowski sum: }
            A + B := \{ a + b \mid a \in A, b \in B \}
        \]
    </p>
    <div class="center">
        <svg width="720" height="150" viewBox="0 60 720 210">
            <g transform="translate(50, 150)">
                <line x1="0" y1="0" x2="100" y2="0" class="shape1" />
                <text x="50" y="80" text-anchor="middle">A</text>
            </g>
            <text x="200" y="165" text-anchor="middle">+</text>
            <g transform="translate(260, 100)">
                <polygon points="
                50,0
                93.3,25
                93.3,75
                50,100
                6.7,75
                6.7,25
                " class="shape2" />
                <text x="50" y="130" text-anchor="middle">B</text>
            </g>
            <text x="410" y="165" text-anchor="middle" class="operator">=</text>
            <g transform="translate(470, 100)">
                <polygon points="
                50,0        
                150,0       
                193.3,25    
                193.3,75    
                150,100     
                50,100      
                6.7,75      
                6.7,25      
                " class="shape3" />
                <text x="100" y="130" text-anchor="middle">A + B</text>
            </g>
        </svg>
    </div>
    <p class="fragment">
        Minkowski sum of two convex shapes is convex.
        <span class="fragment">
            The scaling of a convex shape remain convex
            (for positive scalar).
        </span>
    </p>
    <div class="fragment">
        <div class="problem">
            How does Minkowski <em class="highlight">sum</em>
            and (positive) <em class="highlight">scaling</em>
            interact with <em class="highlight">volume</em>?
        </div>
        <p>
            \[
                \operatorname{vol}(\lambda_1 A + \lambda_2 B) = \;?
            \]
        </p>
    </div>
    <div class="fragment">
        <div class="problem" data-id="prob2">
            How does vector <em class="highlight">sum</em>
            and <em class="highlight">scaling</em>
            interact with <em class="highlight">norm</em>?
        </div>
        <p>
            \[
                \| \lambda_1 \boldsymbol{a} + \lambda_2 \boldsymbol{b} \|^2 = \;?
            \]
        </p>
    </div>
</section>
<section data-auto-animate>
    <div>
        <div class="problem" data-id="prob2">
            How does vector <em class="highlight">sum</em>
            and <em class="highlight">scaling</em>
            interact with <em class="highlight">norm</em>?
        </div>
        <p>
            \[
                \| \lambda_1 \boldsymbol{a} + \lambda_2 \boldsymbol{b} \|^2 = \;?
            \]
        </p>
    </div>
    <br/>
    <div class="fragment">
        <p>
            Is there a symmetric bilinear form $B(\cdot,\cdot)$
            such that
            \[
                \| \lambda_1 \boldsymbol{a} + \lambda_2 \boldsymbol{b} \|^2 =
                \|\boldsymbol{a}\|^2 \lambda_1^2 \;+\;
                \class{highlight}{2 B(\boldsymbol{a},\boldsymbol{b})} \, \lambda_1 \lambda_2 \;+\;
                \|\boldsymbol{b}\|^2 \lambda_2^2 
                \;?
            \]  
        </p>
    </div>
    <br/>
    <ul>
        <li class="fragment">
            Yes... as long as the norm satisfies the parallelogram law.
        </li>
        <li class="fragment">
            It is unique.
        </li>
        <li class="fragment">
            $B$ is given by the polarization identity:
            \[
                B(\boldsymbol{a},\boldsymbol{b}) =
                \frac{1}{2} \left(
                    \|\boldsymbol{a}+\boldsymbol{b}\|^2 -
                    \|\boldsymbol{a}\|^2 -
                    \|\boldsymbol{b}\|^2
                \right)
            \]
        </li>
    </ul>
</section>
<section>
    <p>Come back to the problem...</p>
    <div>
        <div class="problem">
            How does Minkowski <em class="highlight">sum</em>
            and (positive) <em class="highlight">scaling</em>
            interact with <em class="highlight">volume</em>?
        </div>
        <p>
            \[
                \operatorname{vol}(\lambda_1 A + \lambda_2 B) = \;?
            \]
        </p>
    </div>
    <br/>
    <p class="fragment">
        Is there a bilinear (with respect to "$+$") function
        $M(\,\cdot\,,\cdot\,)$ such that
        \[
            \operatorname{vol}(\lambda_1 A + \lambda_2 B) =
            \operatorname{vol}(A) \lambda_1^2 \;+\;
            \class{highlight}{M(A,B)} \, \lambda_1 \lambda_2 \;+\;
            \operatorname{vol}(B) \lambda_2^2 
            \;?
        \]
    </p>
    <br/>
    <ul class="fragment">
        <li>
            Yes, it exists!
        </li>
        <li>
            It's unique!
        </li>
    </ul>
    <p class="fragment">
        It is given by the polarization identity:
        \[
            M(A,B) =
                \operatorname{vol}(A+B) -
                \operatorname{vol}(A) -
                \operatorname{vol}(B)
        \]
    </p>
</section>
<section>
    <div class="center">
        <svg width="960" height="460" id="canvas">
            <text x="250" y="390">+</text>
            <text x="480" y="390">=</text>
        </svg>
    </div>
    
    <div class="cols">
        <div class="col">
            <label>$\lambda_1$</label>
            <input type="range" min="30" max="120" value="100" class="slider" id="scale1">
        </div>
        <div class="col">
            <label>$\lambda_2$</label>
            <input type="range" min="30" max="100" value="80" class="slider" id="scale2">
        </div>
        <div class="col">
            <label class="switch">
                <input type="checkbox" id="showarea">
                Cells
            </label>
        </div>
        <div class="col">
        </div>
    </div>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script>
        d3.select("#scale1")  .on("input", function() { update(); });
        d3.select("#scale2")  .on("input", function() { update(); });
        d3.select("#showarea").on("input", function() { showarea = this.checked; update(); });

        let showarea = false;
        let A = [
            [  0,   0],
            [200,   0],
            [200, 200],
            [  0, 200]
        ];
        let B = [
            [100,200],
            [200,100],
            [0,0],
        ];
        let tA = [  10, 10];  // translation for A
        let tB = [ 280, 10];  // translation for B
        let tM = [ 520, 10];  // translation for A+B

        let svg    = d3.select("#canvas");
        let width  = svg.attr("width");
        let height = svg.attr("height");

        let sA  = undefined;   // scaled and shifted version of A
        let sB  = undefined;   // scaled and shifted version of B
        let sM  = undefined;   // scaled and shifted version of A+B
        let sMA = undefined;
        let sMB = undefined;

        let oA  = svg.append("path").attr("class", "shape1");   // outline of A
        let oB  = svg.append("path").attr("class", "shape2");   // outline of B
        let oM  = svg.append("path").attr("class", "shape3");   // outline of A+B
        let oMA = svg.append("path").attr("class", "shape1");   // outline of A in A+B
        let oMB = svg.append("path").attr("class", "shape2");   // outline of B in A+B

        update();

        function update () {
        let s1 = d3.select("#scale1").property("value");
        let s2 = d3.select("#scale2").property("value");
        let v1 = s1 / 100;
        let v2 = s2 / 100;
        let vA = A.map( x => [ v1*x[0], v1*x[1] ]);
        let vB = B.map( x => [ v2*x[0], v2*x[1] ]);
        sA  = vA.map( x => [ tA[0]+x[0], height-x[1]-tA[1] ] );
        sB  = vB.map( x => [ tB[0]+x[0], height-x[1]-tB[1] ] );
        sM  = vA.map( a => vB.map( b => ([ tM[0]+a[0]+b[0], height-tM[1]-a[1]-b[1]]))).flat();
        sMA = vA.map( a => [ tM[0]+a[0], height-tM[1]-a[1] ]);
        sMB = vB.map( b => [ tM[0]+b[0]+vA[2][1], height-tM[1]-b[1]-vA[2][1] ]);

        oA.datum(sA).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
        oB.datum(sB).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
        oM.datum(d3.geom.hull(sM)).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
        if (showarea) {
            oMA.datum(sMA).attr("d", d => "M" + d.join("L") + "Z").style("opacity",1);
            oMB.datum(sMB).attr("d", d => "M" + d.join("L") + "Z").style("opacity",1);
        } else {
            oMA.style("opacity",0);
            oMB.style("opacity",0);
        }
        }
    </script>
    <p>
        \[
        \text{MVol}(A,B) = \text{Coef. of } \lambda_1 \lambda_2 
        \text{ in }
        (\lambda_1 A + \lambda_2 B)
        \]
    </p>
    <p class="fragment">
        <strong class="highlight">
            Mixed cells:
        </strong>
        cells in a <em>well-behaving</em> subdivision of
        $\lambda_1 A + \lambda_2 B$ that
        has positive contribution to the mixed volume.
    </p>
</section>
<section data-auto-animate>
    <h3>Well-behaving subdivisions</h3>
    <div class="definition" data-id="def-mixed-subdiv">
        For finite sets $S_1,\ldots,S_n \subset \mathbb{R}^n$
        (or point configurations), a
        <strong class="term">
            mixed subdivision
        </strong>
        $M$ of $(S_1,\ldots,S_n)$ is a subdivision of
        $\sum_{i=1}^n S_i$ such that
        <ul>
            <li>
               Each cell $C$ of $M$ can be expressed as a Minkowski sum $C = \sum_{i=1}^n C_i$ with $C_i \subseteq S_i$;
            </li>
            <li>
                If $A = \sum_{i=1}^n A_i$ with $A_i \subseteq S_i$
                and $B = \sum_{i=1}^n B_i$ with $B_i \subseteq S_i$
                are cells in $M$ and $A \cap B \neq \varnothing$, then
                $A \cap B = \sum_{i=1}^n A_i \cap B_i$.
            </li>
        </ul>
    </div>
    <div class="fragment">
        <p>
            With these conditions, in the $n=2$ case,
            \[
                \{ 
                    (\class{highlight}{\lambda_1} C_1 , \class{highlight}{\lambda_2} C_2)
                    \;\mid\;
                    (C_1,C_2) \in M
                \}
            \]
            form a fine mixed subdivision for
            $(\class{highlight}{\lambda_1} S_1, \class{highlight}{\lambda_2} S_2)$.
        </p>
        <p class="fragment">
            \[
                \begin{aligned}
                    \operatorname{vol}(\lambda_1 S_1 + \lambda_2 S_2)
                    &=
                    \sum_{C \in M} \operatorname{vol}(\lambda_1 C_1 + \lambda_2 C_2) \\
                    &=
                    \sum_{C \in M} \lambda_1^{\dim C_1} \lambda_2^{\dim C_2} \operatorname{vol}(C_1 + C_2)
                \end{aligned}
            \]
        </p>

    </div>
</section>
<section data-auto-animate>
    <div>
        <p>
            \[
                \begin{aligned}
                    \operatorname{vol}(\lambda_1 S_1 + \lambda_2 S_2)
                    &=
                    \sum_{C \in M} \operatorname{vol}(\lambda_1 C_1 + \lambda_2 C_2) \\
                    &=
                    \sum_{C \in M} \lambda_1^{\dim C_1} \lambda_2^{\dim C_2} \operatorname{vol}(C_1 + C_2)
                \end{aligned}
            \]
        </p>
        <p>
            <strong class="term">
                Mixed cells:
            </strong>
            cells in a <em class="highlight">mixed subdivision</em>
            that has positive contribution to the mixed volume.
            \[
                \operatorname{MV}(S_1,\ldots,S_n) =
                \sum_{C \in M \,,\, \dim C_i = 1}
                \operatorname{vol}(C)
            \]
        </p>
    </div>
    <div class="fragment">
        <p>
            How to find mixed cells?
            A naive approach:
        </p>
        <ul>
            <li>
                Lift the points in $S_i$ to $\mathbb{R}^{n+1}$ using a
                lifting function $\omega_i : S_i \to \mathbb{R}$;
            </li>
            <li>
                Compute the convex hull of the lifted points;
            </li>
            <li>
                Project the lower hull back to $\mathbb{R}^n$.
            </li>
        </ul>
    </div>
</section>
<section>
    <h3>Digression: Mixed volume vs. volume</h3>
    <p>
        Which one is easier to compute?
        <em>
            Volume and mixed volume computations are both #P.
        </em>
    </p>
    <p class="fragment smaller lowlight">
        Dyer, Gritzmann, Hufnagel.
        <em>On The Complexity of Computing Mixed Volumes.</em>
        SIAM J Comput 27, 1998
    </p>
    <div class="theorem fragment">
        (C. 2020)
        <span class="smaller lowlight">
            <em>Volume of convex polytopes equals mixed volume of simplices.</em>
            Arch. Math. 120.
        </span>
        For $m$ distinct points
        $\{ \mathbf{p}_1, \dots, \mathbf{p}_m \} \subset \mathbb{R}^n$,
        with $m > n$
        \[
            \operatorname{Vol} (
                \operatorname{conv}
                \{\,
                    \mathbf{p}_1, \dots, \mathbf{p}_m
                \}
            ) =
            \operatorname{MV} (
                \Delta(\mathbf{p}_1), \dots, \Delta(\mathbf{p}_m)
            )
        \]
        where each $\Delta(\mathbf{p}_i)$ is a simplex
        of dimension $m-n$ in $\mathbb{R}^m$.
    </div>
    <p class="fragment">
        The specialized problem of computing mixed volume of simplices is
        at least as "hard" as the general problem of computing volume.
    </p>
    <br/>
    <p class="fragment">
        \[
            \begin{gathered}
            \text{General} \\
            \text{volume computation}
            \end{gathered}
            \quad\approx\quad
            \begin{gathered}
            \text{Very special} \\
            \text{mixed volume computation}
            \end{gathered}
        \]
    </p>
</section>
<section>
    <h3>Digression: Mixed volume $=$ normalized volume?</h3>
    <div class="theorem">
        If $A$ and $B$ "touch" all the edges of
        $\text{conv}(A \cup B)$, then
        <p>
            \[
                \operatorname{MV}(A,B) \;=\; \operatorname{Vol}_2( \text{conv} (A \cup B) )
            \]
        </p>
    </div>
    <div class="center">
    <svg width="700" height="250">
        <g transform="scale(1,-1) translate(0,-220)">
            <polygon class="shape1"
                points="0,0 200,0 200,200 0,200" />
        </g>
        <g transform="scale(1,-1) translate(250,-220)">
            <polygon class="shape2"
                points="0,0 200,100 100,200" />
        </g>
        <g transform="scale(1,-1) translate(500,-220)">
            <polygon class="shape1"
                points="0,0 200,0 200,200 0,200" />
            <polygon class="shape2"
                points="0,0 200,100 100,200" />
        </g>
        <g transform="translate(120,250) scale(0.6,0.6)">
            <text x="0" y="0" fill="black"> Mixed volume: 8</text>
        </g>
        <g transform="translate(505,250) scale(0.6,0.6)">
            <text x="0" y="0" fill="black"> Normalized vol. = 8</text>
    </svg>
    </div>    
    <p class="small lowlight">
        Rojas, J. Maurice. 
        <em>A convex geometric approach to counting the roots of a polynomial system.</em>
        Theoretical Computer Science 133.1 (1994): 105-140.
    </p>
    <p class="small lowlight">
        Bihan, Frédéric, and Ivan Soprunov. 
        <em>Criteria for strict monotonicity of the mixed volume of convex polytopes.</em>
        Advances in Geometry 19.4 (2019): 527-540.
    </p>
    <p class="small lowlight">
        Chen, Tianran.
        <em>Unmixing the mixed volume computation.</em>
        Discrete & Computational Geometry 62.1 (2019): 55-86.
    </p>
</section>
<section>
    <h3>BKK bound</h3>
    <div class="theorem">
        (BKK, again)
        Given a system of Laurent polynomials
        $f_1,\dots,f_n$ in $(x_1,\dots,x_n)$
        with <span class="emph">generic</span> coefficients,
        the number of isolated common roots in
        $(\mathbb{C}^*)^n$ is bounded by
        \[ \text{MV}(\text{Newt}(f_1),\dots,\text{Newt}(f_n)) \]
    </div>
    <p class="fragment">
        What is the generic $\mathbb{C}$-root count for
        \[
            \begin{cases}
                a x^{2} y^{1} + b x^{1} y^{2} + c x^{0} y^{0} \\
                d x^{2} y^{0} + e x^{0} y^{2} + f x^{2} y^{2} + g x^{0} y^{0}
            \end{cases}
            \;?
        \]
    </p>
    <div class="center fragment">
        <img src="two-np.png" alt="" width="720"/>
    </div>
</section>
<section>
    <h3>
        Puzzle: Mixed volume in triangulation?
    </h3>
    <p>
        A triangulation of
        \[
            \operatorname{conv}(\lambda_1 A \cup \lambda_2 B)
        \]
    </p>
    <div class="center">
        <svg width="420" height="400" id="vmvol_canvas"></svg>
    </div>
    <div class="cols">
        <div class="col">
            <label>$\lambda_1$</label>
            <input type="range" min="70" max="200" value="120" class="slider" id="vmvol_scale1">
        </div>
        <div class="col">
            <label>$\lambda_2$</label>
            <input type="range" min="70" max="180" value="120"  class="slider" id="vmvol_scale2">
        </div>
        <div class="col">
            <label class="switch">
                <input type="checkbox" id="vmvol_showarea">
                Cells
            </label>
        </div>
    </div>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script>
        var vmvol_showarea = false;

        d3.select("#vmvol_scale1")  .on("input", function() { vmvol_update(); });
        d3.select("#vmvol_scale2")  .on("input", function() { vmvol_update(); });
        d3.select("#vmvol_showarea").on("input", function() { vmvol_showarea = this.checked; vmvol_update(); });

        let vmvol_svg    = d3.select("#vmvol_canvas");
        let vmvol_width  = vmvol_svg.attr("width");
        let vmvol_height = vmvol_svg.attr("height");

        var orig_x = 20;
        var orig_y = 20;

        var vmvol_A = [
            [  0,   0],
            [200,   0],
            [200, 200],
            [  0, 200]
        ]

        var vmvol_B = [
            [100,200],
            [200,100],
            [0,0],
        ]

        let vmvol_sA = undefined;   // scaled version of A
        let vmvol_sB = undefined;   // scaled version of B
        let vmvol_sH = undefined;   // conv( sA U tB )

        var vmvol_oH    = vmvol_svg.append("path").attr("class", "shape3");
        var vmvol_oA    = vmvol_svg.append("path").attr("class", "shape4");
        var vmvol_oB    = vmvol_svg.append("path").attr("class", "shape4");
        var vmvol_area1 = vmvol_svg.append("path").attr("class", "shape1");
        var vmvol_area2 = vmvol_svg.append("path").attr("class", "shape1");
        var vmvol_area3 = vmvol_svg.append("path").attr("class", "shape1");
        var vmvol_area4 = vmvol_svg.append("path").attr("class", "shape1");

        vmvol_update();

        function vmvol_update() {
            let lineto = (d => "M" + d.join("L") + "Z");
            let s1 = +d3.select("#vmvol_scale1").property("value");
            let s2 = +d3.select("#vmvol_scale2").property("value");
            let v1 = s1 / 100;
            let v2 = s2 / 100;
            let sA = A.map( x => [ orig_x + v1*x[0], vmvol_height - orig_y - v1*x[1] ]);
            let sB = B.map( x => [ orig_x + v2*x[0], vmvol_height - orig_y - v2*x[1] ]);
            let sH = sA.concat(sB);

            vmvol_oH.datum(d3.geom.hull(sH)).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
            if (vmvol_showarea) {
                vmvol_area1.datum([sA[0],sA[1],sB[1]]).attr("d", lineto).style("opacity",1);
                vmvol_area2.datum([sA[0],sA[2],sB[1]]).attr("d", lineto).style("opacity",1);
                vmvol_area3.datum([sA[0],sA[2],sB[0]]).attr("d", lineto).style("opacity",1);
                vmvol_area4.datum([sA[0],sA[3],sB[0]]).attr("d", lineto).style("opacity",1);
            } else {
                vmvol_area1.style("opacity",0);
                vmvol_area2.style("opacity",0);
                vmvol_area3.style("opacity",0);
                vmvol_area4.style("opacity",0);
            }
            vmvol_oA.datum(sA).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
            vmvol_oB.datum(sB).attr("d", function(d) { return "M" + d.join("L") + "Z"; });
        }
    </script>
</section>
<section class="titlepage">
    <br/>
    <br/>
    <h1>Thank You!</h1>

    <br/>
    <p>
        <code>ti@nranchen.org</code>
    </p>
    <p class="lowlight">
        <code>
        http://www.tianranchen.org/
        </code>
    </p>
</section>